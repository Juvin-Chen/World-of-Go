#  📘 第 4 章： 接口、面向对象与泛型

本章节重点介绍了 Go 语言如何通过方法、接口和组合来实现面向对象编程（OOP）的特性，并引入了 Go 1.18 之后强大的泛型机制。

------

## 1. 变量创建与指针补充 (Pointers & Memory)

在 Go 中，创建变量和指针有多种方式，编译器会根据逃逸分析（Escape Analysis）决定变量分配在栈上还是堆上。

- **方式 1：&取地址**：`p := &v1`，获取已有变量的地址。
- **方式 2：&取字面量地址**：`p := &Vertex{3, 4}`，直接创建并获取结构体指针。
- **方式 3：`new()` 函数**：`p := new(T)`，创建一个 T 类型的零值并返回其指针。
  - 对于 `int` 零值是 `0`。
  - 对于结构体，字段均为其类型的零值。

------

## 2. 方法 (Methods)

方法是带有 **接收者 (Receiver)** 的函数。Go 没有类，但可以为结构体（或其他自定义类型）定义方法。

### 值接收者 vs. 指针接收者

| **特性**       | **值接收者 (v Vertex)** | **指针接收者 (v \*Vertex)** |
| -------------- | ----------------------- | --------------------------- |
| **修改原对象** | 否（操作的是副本）      | **是**（直接操作地址）      |
| **性能**       | 涉及大对象时有复制开销  | **高**（仅传递 8 字节地址） |
| **语法糖**     | 均可调用（Go 自动转换） | 均可调用（Go 自动转换）     |

> **💡 Go 贴心语法糖**：即使 `v` 是一个值，你也可以直接调用指针接收者的方法 `v.Scale(10)`，Go 会自动将其解释为 `(&v).Scale(10)`。

------

## 3. 接口 (Interfaces)

Go 的接口实现是 **隐式 (Implicit)** 的。只要一个类型实现了接口要求的所有方法，它就自动实现了该接口，**不需要** `implements` 关键字。

### 空接口 `interface{}` (any)

- **定义**：没有任何方法要求的接口。
- **作用**：万能容器。任何类型都实现了空接口，因此可以装下任何值。
- **应用**：常用于需要处理未知类型数据的场景，如 `fmt.Println`。

------

## 4. 类型转换与断言 (Type Conversion & Assertions)

### 4.1 基本类型转换

使用 `type_name(expression)` 格式。对于字符串与数字的转换，需使用 `strconv` 包。

- `strconv.Atoi(str)`：字符串转整数。
- `strconv.Itoa(num)`：整数转字符串。
- `strconv.ParseFloat(str, 64)`：字符串转浮点数。

### 4.2 接口类型断言

由于接口（尤其是空接口）可以装载任何内容，在使用前需要通过 **类型断言** 确认其身份。

- **安全断言**：`v, ok := i.(T)`。如果断言失败，`ok` 为 `false`，程序不会崩溃。
- **非安全断言**：`v := i.(T)`。如果断言失败，程序会直接 **panic (崩溃)**。

------

## 5. 泛型 (Generics)

泛型允许我们编写处理多种类型的通用代码，避免重复劳动。

### 核心语法

- **定义**：使用 `[T any]` 或 `[T comparable]` 定义类型参数。
- **约束 (Constraints)**：
  - `any`：接受任何类型（同 `interface{}`）。
  - `comparable`：接受支持 `==` 和 `!=` 比较的类型。
  - **联合约束**：使用 `|` 定义特定类型集合，如 `type Number interface { int | float64 }`。

### 应用场景

- **泛型函数**：如 `Swap[T any](a, b T)`。
- **泛型结构体**：如 `Stack[T any]` 栈结构。

------

## 6. 结构体嵌入与组合 (Composition)

**重点：Go 语言没有继承 (Inheritance)，只有组合 (Composition)**。

- **匿名嵌入**：在结构体中只写类型名而不写字段名。
- **代码复用**：嵌入后，外层结构体可以直接访问内层结构体的字段和方法，实现类似“继承”的效果。

Go

```
type Admin struct {
    User  // 匿名嵌入
    Level string
}
// admin.Name 直接访问 User.Name
```

------

## 🛡️ C++ 选手注意事项 (Cheatsheet)

1. **没有 Class**：Go 使用 `struct` + `method` 替代。
2. **没有显式接口**：不需要 `class Dog : public Animal`。只要你有 `Speak()` 方法，你就是 `Animal`。
3. **String 是不可变的**：虽然可以使用 `sw.str += "..."` 重新赋值，但底层是创建了新字符串。
4. **泛型不是模板**：Go 泛型在编译时和 C++ Template 的处理机制不同，Go 更加简洁，但没有 C++ 模板元编程那么复杂。