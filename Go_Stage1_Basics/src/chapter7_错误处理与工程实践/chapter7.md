# 📘 第 7 章: 错误处理与工程实践 (Error Handling & Engineering)

本章是 Go 语言设计的哲学核心。Go 摒弃了 `try-catch`，强制开发者显式处理每一个可能发生的错误。

## 1. Defer (延迟执行)

`defer` 是 Go 语言用来管理资源释放的神器。

- **机制**: 将函数推迟到**当前函数返回前**执行。
- **数据结构**: 栈 (Stack) —— **后进先出 (LIFO)**。
  - 先定义的 `defer` 后执行。
- **典型场景**:
  - `f.Close()` (关闭文件)
  - `mu.Unlock()` (解锁)
  - `db.Close()` (关闭数据库)
- **注意**: `defer` 的参数在声明时就计算好了（值拷贝），而不是执行时才计算。

## 2. 错误处理 (Error Handling)

Go 认为**错误是正常流程的一部分**，而不是“异常”。

- **定义**: `error` 是一个内置接口。

- **创建**: `errors.New("message")` 或 `fmt.Errorf("... %w ...")`。

- **处理范式**:

  Go

  ```
  if err != nil {
      // 处理错误（打印、返回、降级）
      return err
  }
  // 正常逻辑
  ```

- **C++ 对比**:

  - C++: `try { ... } catch (e) { ... }` (隐式控制流，跳跃大)。
  - Go: 显式检查，代码逻辑更线性、可读。

## 3. Go Modules (工程化基石)

`Go Modules` 是现代 Go 项目的依赖管理标准。

### 3.1 核心价值

- **版本锁**: `go.mod` 记录直接依赖，`go.sum` 记录依赖哈希（防篡改）。
- **去 GOPATH**: 项目可以放在磁盘任何位置，不再受限于 `$GOPATH/src`。
- **语义化版本**: 严格遵循 `vMajor.Minor.Patch`。

### 3.2 常用命令 (Cheatsheet)

| **命令**                     | **作用**                                   |
| ---------------------------- | ------------------------------------------ |
| `go mod init <module_name>`  | 初始化项目，生成 go.mod                    |
| `go mod tidy`                | **最常用**：自动添加缺少的包，删除没用的包 |
| `go get <package>@<version>` | 下载/更新指定版本的依赖                    |
| `go mod verify`              | 校验依赖包完整性                           |

### 3.3 核心结论

把 `Go Modules` 当作你的**智能管家**。你只管写代码（import），剩下的全交给 `go mod tidy`。

