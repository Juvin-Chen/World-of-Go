# 📘 第 5 章: Go 并发编程 (The Killer Feature)

> **Go 语言并发哲学**： "Do not communicate by sharing memory; instead, share memory by communicating." “不要通过共享内存来通信，而要通过通信来共享内存。”

Go 语言之所以被称为“21 世纪的 C 语言”，最大的杀手锏就是其原生支持的高并发模型。本章我们将深入理解 **Goroutine**（执行体）和 **Channel**（连接体）。

------

## 1. 核心概念三驾马车

### 1.1 Goroutine (协程) —— "轻量级临时工"

- **定义**：Go 运行时（Runtime）管理的轻量级线程。
- **对比 Java/C++ 线程**：
  - **OS 线程**：重量级（MB级内存），创建慢，切换成本高（内核态）。
  - **Goroutine**：轻量级（KB级内存），创建快，切换成本低（用户态）。
- **启动方式**：`go func()`。
- **特性**：非阻塞（Fire and Forget）。一旦启动，它就与主程序并发运行。

### 1.2 Channel (通道) —— "传送带"

- **定义**：Goroutine 之间的通信管道。
- **作用**：用来传递数据，实现同步。
- **方向**：
  - `ch <- v`：**发送**（数据流进管道）。
  - `v := <-ch`：**接收**（数据流出管道）。

### 1.3 GMP 调度模型 (Scheduler) —— "包工头机制"

这是 Go 高效的底层秘密（面试必问）：

- **G (Goroutine)**：待执行的任务（搬砖任务）。
- **M (Machine)**：系统内核线程（真实的建筑工人）。
- **P (Processor)**：逻辑处理器/上下文（包工头，手握任务队列）。
- **机制**：Go 用极少的 M（工人），配合 P（工头）的调度，高效地处理成千上万个 G（任务）。

------

## 2. Goroutine 的生命周期

Go

```
func main() {
    go say("hello") // 启动子协程
    fmt.Println("main")
}
```

- **非阻塞**：主程序执行到 `go` 关键字时，不会等待子协程执行完，而是立刻往下走。
- **生死与共**：**主协程（main）一旦退出，所有子协程（无论是否执行完）都会被强制销毁**。因此，我们需要同步机制（如 Channel 或 WaitGroup）来“拉住”主协程。

------

## 3. Channel 深度解析

Channel 是类型相关的，一个 `chan int` 只能传递 `int`。

### 3.1 无缓冲通道 (Unbuffered Channel)

- **别名**：同步通道。
- **比喻**：**“接力赛交棒”**。
- **特性**：**不见不散**。
  - 发送者 (`ch <- 1`) 会**阻塞**，直到有人来接收。
  - 接收者 (`<-ch`) 会**阻塞**，直到有人来发送。
  - **死锁风险**：如果只有发送者没有接收者（或反之），协程会永远卡死。

### 3.2 有缓冲通道 (Buffered Channel)

- **创建**：`make(chan int, 3)` (容量为 3)。
- **比喻**：**“快递柜”**。
- **特性**：**异步处理**。
  - 只要柜子没满，发送者放了就走（不阻塞）。
  - 只要柜子没空，接收者取了就走（不阻塞）。
  - **阻塞条件**：柜子满了（发送阻塞），柜子空了（接收阻塞）。

### 3.3 遍历与关闭

- **关闭**：`close(ch)`。告诉接收方：“没有更多数据了”。

- **遍历**：

  Go

  ```
  // 推荐写法：自动判断 channel 是否关闭
  for v := range ch {
      fmt.Println(v)
  }
  ```

  > **注意**：如果通道不关闭，`range` 会一直等待新数据，导致死锁。

------

## 4. 流程控制神器：Select

`select` 是 Go 里的**多路复用器**，专用于处理 Channel 操作。

- **作用**：同时监听多个 Channel，哪个通了走哪个。
- **规则**：
  1. 如果多个 case 同时满足（都有数据），**随机选择**一个执行。
  2. 如果没有 case 满足，且有 `default`，执行 `default`。
  3. 如果没有 case 满足，且无 `default`，**阻塞等待**。

**典型应用：超时控制与退出**

Go

```
select {
case msg := <-c:
    fmt.Println("收到消息", msg)
case <-time.After(time.Second * 5):
    fmt.Println("超时了！不等了")
case <-quit:
    fmt.Println("收到退出信号")
    return
}
```

------

## 5. 同步工具：Sync.WaitGroup

当不涉及数据传输，仅仅需要**等待一组协程完成**时，使用 `WaitGroup`。

### 5.1 "班长点名" 模型

1. **`wg.Add(1)`**：班长（主协程）在名单上记一笔（任务 +1）。
2. **`go worker()`**：同学（子协程）去干活。
3. **`defer wg.Done()`**：同学干完活，划掉名字（任务 -1）。
4. **`wg.Wait()`**：班长在门口死等，直到名单清零（阻塞主协程）。

### ⚠️ 严重避坑指南

- **传递方式**：`WaitGroup` 必须通过**指针 (`&wg`)** 传递给子函数！
- **原因**：Go 是值传递。如果你传的是值，子协程拿走的是“点名册的复印件”，他在复印件上划掉名字，班长手里的原件永远不会变，导致**死锁**。

------

## 6. 高级特性速览 (Advanced)

### 6.1 Context (上下文) —— "协程遥控器"

- **作用**：控制一棵协程树的生命周期（超时、取消）。
- **场景**：Web 服务器处理请求时，启动了数据库查询协程。如果用户关闭了浏览器，可以用 Context 一键取消所有后台查询，节省资源。

### 6.2 Mutex (互斥锁) —— "卫生间门锁"

- **作用**：保护共享资源（如全局变量、Map）。
- **逻辑**：`Lock()` 加锁 -> 修改数据 -> `Unlock()` 解锁。
- **对比 Channel**：
  - **Channel**：负责**传输**数据，解耦。
  - **Mutex**：负责**保护**数据，高性能。

------

## 7. 常见并发灾难 (Pitfalls)

### 💀 死锁 (Deadlock)

- **现象**：程序卡住不动，控制台报错 `fatal error: all goroutines are asleep - deadlock!`。
- **常见原因**：
  1. 无缓冲通道：只有发送者，没有接收者（或反之）。
  2. `WaitGroup` 计数器没归零（忘了 Done 或 Add 多了）。
  3. 单协程自己给自己发数据。

### 💥 数据竞争 (Data Race)

- **现象**：多个协程同时读写同一个变量，导致数据错乱（count 本该是 2000，结果是 1998）。
- **检测工具**：运行代码时加上 `-race` 参数。 `go run -race main.go`
- **解决方案**：使用 `Channel` 串行化处理，或使用 `Mutex` 加锁。

------

### 📝 Chapter 5 结语

这一章是 Go 语言最迷人也最难驾驭的部分。

- **初学者**：重点掌握 `go` 启动、`make(chan)`、`<-` 读写、`select` 基本用法。
- **进阶**：需要通过大量实战去理解何时用 Channel，何时用 Mutex，以及如何避免死锁。