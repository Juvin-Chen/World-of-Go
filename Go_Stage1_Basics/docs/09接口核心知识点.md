# Go 语言接口核心知识点笔记

## 一、接口核心实现规则（核心！）

Go 语言接口遵循「鸭子类型」：**只要一个类型拥有接口要求的所有方法，就自动实现了该接口**，与类型本身是结构体、int、切片等无关。

- 核心判断依据：「是否有接口要求的方法」，而非「类型本身是什么」；
- 实现方式：隐式实现（无需显式声明继承，绑定方法即实现）。
- go语言里面所有类型都可以实现接口

## 二、不同类型实现接口实战示例

### 1. 定义基础接口

```go
package main

import "fmt"

// 定义普通接口：包含一个Say()方法
type Speaker interface {
	Say() // 接口要求的唯一方法
}

// 通用函数：接收Speaker接口类型参数（可接收所有实现该接口的类型）
func LetItSpeak(s Speaker) {
	s.Say()
}
```

### 2. 结构体实现接口（最常见场景）

```go
// 结构体类型
type Person struct {
	Name string
}

// 给Person绑定Say方法 → 自动实现Speaker接口
func (p Person) Say() {
	fmt.Printf("我是结构体：%s\n", p.Name)
}
```

### 3. int 别名实现接口（基础类型也能实现）

基础类型（int/float 等）本身不能直接绑定方法，但通过「类型别名」绑定后可实现接口：

```go
// int别名类型（本质仍是int）
type MyInt int

// 给MyInt绑定Say方法 → 自动实现Speaker接口
func (m MyInt) Say() {
	fmt.Printf("我是int别名：%d\n", m)
}
```

### 4. 切片别名实现接口（复合类型也能实现）

```go
// 切片别名类型
type StringSlice []string

// 给StringSlice绑定Say方法 → 自动实现Speaker接口
func (s StringSlice) Say() {
	fmt.Printf("我是切片别名：%v\n", s)
}
```

### 5. 测试：所有类型均可传入接口参数

```go
func main() {
	// 结构体实例
	p := Person{Name: "小明"}
	LetItSpeak(p) // 合法：Person实现了Speaker

	// int别名实例
	var num MyInt = 100
	LetItSpeak(num) // 合法：MyInt实现了Speaker

	// 切片别名实例
	slice := StringSlice{"苹果", "香蕉"}
	LetItSpeak(slice) // 合法：StringSlice实现了Speaker
}
```

```
我是结构体：小明
我是int别名：100
我是切片别名：[苹果 香蕉]
```

## 三、空接口（interface {}）详解

### 1. 本质

空接口是特殊接口：**无任何方法要求**，因此 Go 中「所有类型」都天然实现了空接口（满足「拥有 0 个方法」的条件）。

### 2. 核心价值

解决强类型语言中「通用函数 / 通用数据结构」的问题，可接收任意类型的值，且保留值的真实类型信息（区别于 C++ 的 void*）。

### 3. 代码示例

```
// 空接口参数：接收任意类型
func printAny(v interface{}) {
	fmt.Printf("Type: %T, Value: %v\n", v, v)
}

func main() {
	printAny(100)          // Type: int, Value: 100
	printAny("测试")        // Type: string, Value: 测试
	printAny([]int{1,2,3}) // Type: []int, Value: [1 2 3]
}
```

## 四、Go 接口 vs C++ 纯虚类（接口）

| 特性             | Go 接口                         | C++ 纯虚类（接口）                              |
| :--------------- | :------------------------------ | :---------------------------------------------- |
| 实现方式         | 隐式实现（绑定方法即实现）      | 显式继承（必须写 `class A : public Interface`） |
| 实现者类型       | 任意类型（结构体 /int/ 切片等） | 仅支持类（结构体）                              |
| 基础类型能否实现 | 能（别名 + 绑定方法）           | 不能（基础类型不是类）                          |
| 类型信息         | 自动保留真实类型                | 需手动强转，易丢失类型信息                      |

## 五、核心总结

1. Go 接口实现看「方法是否匹配」，不看「类型本身」，结构体只是实现接口的一种类型，int / 切片等均可通过别名绑定方法实现；
2. 空接口 `interface{}` 无方法要求，因此所有类型都天然实现，是「万能类型容器」且保留类型信息；
3. 基础类型（int/float）需通过「类型别名」绑定方法，才能实现非空接口。