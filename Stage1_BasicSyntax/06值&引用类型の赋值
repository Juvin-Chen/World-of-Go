# Go 语言基础：值类型 vs 引用类型

在 Go 语言中，数据存储方式主要分为两类：**值类型 (Value Type)** 和 **引用类型 (Reference Type)**。它们的区别决定了变量赋值、内存分配以及修改数据时的行为。

## 1. 值类型 (Value Type)

### 核心概念

* **本质**：变量直接存储**值本身**。
* **常见类型**：
  * 基础类型：`int`, `float`, `bool`
  * 结构体：`struct`
  * 数组：`array`
  * **字符串**：`string` (行为上表现为值类型，底层是指针+长度)
* **内存位置**：
  * 通常存储在**栈 (Stack)** 中（特别是局部变量）。
  * 特例：如果变量在函数外部被使用（逃逸分析），Go 编译器会将其分配到**堆 (Heap)** 中。

### 赋值行为 (拷贝)

当使用 `=` 进行赋值时（如 `j = i`）：

* **动作**：系统会在内存中把 `i` 的值**完整拷贝**一份给 `j`。
* **结果**：`i` 和 `j` 是两个完全独立的数据。修改 `j` **不会** 影响 `i`。
* **获取地址**：可以通过 `&i` 获取变量在内存中的地址（例如 `0xf840000040`，每次运行可能不同）。

> **💡 比喻 (复印件)**：
> 你有一张满分试卷 (i)，复印了一份给同桌 (j)。同桌在复印件上涂改，你的原卷不会变脏。

---

## 2. 引用类型 (Reference Type)

### 核心概念

* **本质**：变量存储的是**数据的内存地址 (指针)**，而不是数据本身。
* **常见类型**：
  * 切片：`slice`
  * 映射：`map`
  * 通道：`channel`
  * 接口：`interface`
  * 指针：`*int` 等
* **内存结构**：
  * 通常包含一个指向底层数据的**指针**。
  * 底层数据可能连续存储（效率高），也可能分散存储。

### 赋值行为 (共享)

当使用 `=` 进行赋值时（如 `r2 = r1`）：

* **动作**：系统只复制了**引用（地址/指针）**，没有复制底层的数据。
* **结果**：`r1` 和 `r2` 指向**同一个**内存地址。
* **副作用**：如果你通过 `r1` 修改了数据，`r2` 读取到的数据**也会随之改变**。

> **💡 比喻 (遥控器)**：
> 你们只有一台电视 (底层数据)。`r1` 是你手里的遥控器，`r2` 是你配给朋友的遥控器。任何一个人换台，大家看到的画面都会变。

---

## 3. 对比总结表

| 特性         | 值类型 (int, bool, string等) | 引用类型 (slice, map等) |
| :----------- | :--------------------------- | :---------------------- |
| **存储内容** | 实际的数值                   | 数据的内存地址 (指针)   |
| **赋值操作** | **拷贝数据** (深拷贝)        | **拷贝地址** (浅拷贝)   |
| **修改影响** | 互不影响，各自独立           | 一变全变，共享状态      |
| **比喻**     | 复印件                       | 房间钥匙 / 遥控器       |

## 4. 特别说明：String 的特殊性

虽然 `string` 在 Go 中被归为**值类型**（表现出不可变性），但它的底层结构其实是一个“混合体”：

1.  它包含一个指向数据的**指针**。
2.  它包含一个记录长度的**数值**。

但因为 Go 规定字符串**不可修改 (Immutable)**，所以我们使用时把它当做纯粹的值类型即可，既享受了引用的轻量（赋值快），又享受了值类型的安全（不担心被意外修改）。