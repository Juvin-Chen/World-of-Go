# Go 语言程序入口核心规则 (Main 函数)

> **💡 一句话记忆**：
> `main` 函数必须住在 `main` 包里；一个屋檐下只能有一个 `main`；但一个大家族（Module）可以有很多个独立门户的 `main`。

## 🔴 规则 1：门牌号必须对 (身份限定)

**`func main()` 只能定义在 `package main` 中。**

* **编译原理**：Go 编译器只认 `package main` 作为可执行程序的入口。
* **错误示范**：如果你在工具包里写 main，它只会被当成一个普通的函数，无法运行。

```go
// ❌ 错误：在非 main 包中定义入口
package utils 

func main() { 
    // 编译器OS：你不是程序的入口，我不会执行你
}

// ✅ 正确
package main

func main() {
    // 程序的唯一入口
}
```

## 🔴 规则 2：一山不容二虎 (唯一性)

**同一个目录（同一个包）下，只能有一个 `func main()`。**

- **场景**：你在同一个文件夹下写了 `a.go` 和 `b.go`，如果你在两个文件里都写了 `main()`，编译器就疯了。
- **报错信息**：`main redeclared in this block`

| **文件名**  | **代码内容**                         | **结果**           |
| ----------- | ------------------------------------ | ------------------ |
| `demo/a.go` | `package main` + `func main() {...}` | **冲突！** 💥       |
| `demo/b.go` | `package main` + `func main() {...}` | (二选一，不能共存) |

------

## 🟢 规则 3：分家过日子 (多入口模式)

**一个「模块 (Module)」可以包含多个 `package main`，只要它们在不同的目录下。**

这是 Go 项目最标准的做法（通常使用 `cmd/` 目录）。每个目录对应一个独立的可执行文件（exe）。

### 📂 推荐的项目结构图 (cmd 模式)

Plaintext

```
my-project/ (根目录/模块)
├── go.mod
├── internal/       <-- 公共逻辑代码
├── pkg/            <-- 公共工具代码
└── cmd/            <-- 【重点在这里】
    ├── app1/       <-- 第一个程序 (比如服务端)
    │   └── main.go (package main) ✅ 独立编译 -> app1.exe
    │
    └── app2/       <-- 第二个程序 (比如后台管理工具)
        └── main.go (package main) ✅ 独立编译 -> app2.exe
```

- **如何运行？**
  - 运行 App1：`go run ./cmd/app1`
  - 运行 App2：`go run ./cmd/app2`
- **原理**：虽然它们都叫 `package main`，但因为在**不同目录**，互不干扰。

------

## 📝 总结 Checklist

- [ ] 我的 `func main` 所在的开头是不是写着 `package main`？
- [ ] 我当前的文件夹里，是不是只有一个 `func main`？
- [ ] 如果我要写两个程序（比如一个客户端、一个服务端），我是不是把它们分到了不同的文件夹里？