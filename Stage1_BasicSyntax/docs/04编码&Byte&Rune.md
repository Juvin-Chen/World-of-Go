# Go 语言核心机制：字符串、Byte 与 Rune

## 1. 核心结论

在 Go 语言中，必须区分**物理存储**和**逻辑字符**：

* **存储层面**：字符串 (`string`) 本质上是一个**只读的 byte 切片**，默认使用 **UTF-8** 编码。
* **逻辑层面**：如果我们想操作“人类眼中的字符”，必须使用 `rune`。

> **一句话心法**：`string` 是集装箱（字节），`rune` 是货物（字符）。

## 2. 三个关键角色

| 关键字    | 类型本质        | 作用                                              | 对应概念        |
| :-------- | :-------------- | :------------------------------------------------ | :-------------- |
| **byte**  | `uint8` (0-255) | **物理存储单位**。无论英文中文，最终都存为 byte。 | 集装箱 / 车厢   |
| **rune**  | `int32`         | **逻辑字符单位**。代表一个 Unicode 码点。         | 货物 / 身份证号 |
| **UTF-8** | 编码规则        | 决定了一个 `rune` 需要塞进几个 `byte` 里。        | 打包手册        |

* **ASCII (英文)**：码点小，1 个 byte 存得下。

* **中文**：码点大，通常需要 **3 个 byte** 连在一起存。

  > 1. **Unicode 完全包含 ASCII**：ASCII 是 Unicode 的 “子集”，且 Unicode 前 128 个字符的编号和 ASCII 完全重合；
  > 2. **UTF 不是 “一个规则”，是一套编码规则家族**：UTF 的作用是把 Unicode 的 “字符编号” 转换成电脑能存储的「字节序列」，常见的有 UTF-8/UTF-16/UTF-32，Go 语言默认用 UTF-8。
  > 3. **rune** 用 4 字节的核心目的：“**统一存储所有 Unicode 字符**” 

## 3. 内存布局示例

假设字符串：`s := "Hi中"`

**物理视图 (Memory View):**
这就是为什么 `len(s)` 等于 5。

| 索引 (Index) |   0    |   1    |       2       |       3       |       4       |
| :----------- | :----: | :----: | :-----------: | :-----------: | :-----------: |
| **Byte 值**  | `0x48` | `0x69` |    `0xE4`     |    `0xB8`     |    `0xAD`     |
| **解释**     |  'H'   |  'i'   | '中' (Part 1) | '中' (Part 2) | '中' (Part 3) |

编码规则存储方式核心特点适用场景UTF-8变长编码（1~4 字节）（rune（int32）的存储占用 4 字节，用来装 Unicode 码点）

1. ASCII 字符（0~127）→ 1 字节（和 ASCII 完全一样）；

2. 中文 / 日文 → 3 字节；
3. Emoji → 4 字节；
4. 兼容 ASCII，无字节序问题

## 4. 常见陷阱与最佳实践

### 陷阱 1：使用 `len()` 计算字数

```go
s := "Hi中"
fmt.Println(len(s)) // 输出 5 (这是字节数，不是字数！)
```

### 陷阱 2：使用 `for i` 遍历中文

这会把一个汉字拆成 3 个乱码字节打印。

Go

```
for i := 0; i < len(s); i++ {
    fmt.Printf("%x ", s[i]) // 只是在遍历 byte 数组
}
```

### 正确做法：使用 `for range` 或类型转换

Go 的 `range` 会自动按照 UTF-8 规则解码，把 byte 组装回 rune。

Go

```
// 方法 A: 遍历 (推荐)
for i, char := range s {
    // char 的类型是 rune (int32)
    fmt.Printf("索引%d: %c\n", i, char) 
}
// 输出:
// 索引0: H
// 索引1: i
// 索引2: 中 (注意：索引直接跳到了 2，因为 '中' 占了 3 个坑，下一个索引会是 5)

// 方法 B: 强制类型转换 (想按字符切片时用)
runes := []rune(s)
fmt.Println(len(runes)) // 输出 3 (正确的字数)
```

## 5. 总结

- Go 的字符串底层就是 **Byte 数组**。
- **只读**：字符串创建后不可变（类似 Java String）。
- **UTF-8**：Go 源码和字符串默认都是 UTF-8 编码。
- **切记**：遇到中文处理，第一时间想到转成 `[]rune` 再操作。

## 6. 进阶疑难：计算机怎么知道“读几个字节”？

**核心疑问**：为什么遍历 `Hi中` 时，计算机会读 `1+1+3` 个字节，而不是胡乱读 `4+1` 个字节？

**原理解析**：
UTF-8 是一种**前缀码**编码。每个字节的**高位比特 (Bits)** 充当了“长度标记”。

| 头部特征 (二进制) | 含义 | 例子 |
| :--- | :--- | :--- |
| **0**xxxxxxx | **我是 ASCII**，这 1 个字节就是全部。 | `0`1001000 ('H') |
| **110**xxxxx | **我是 2 字节领队**，带 1 个跟班。 | (希腊字母等) |
| **1110**xxxx | **我是 3 字节领队**，带 2 个跟班。 | **1110**0100 ('中' 的头) |
| **11110**xxx | **我是 4 字节领队**，带 3 个跟班。 | (Emoji 表情等) |
| **10**xxxxxx | **我是跟班**，必须跟在领队后面。 | ('中' 的后两字节) |

**流程推演 `s := "Hi中"`**：
1.  **Byte 0 (`H`)**: 读到二进制 `0...` -> 判定为 **1字节** 结束。
2.  **Byte 1 (`i`)**: 读到二进制 `0...` -> 判定为 **1字节** 结束。
3.  **Byte 2 (`中`)**: 读到二进制 `1110...` -> 判定为 **3字节** 序列的开始。
    * 计算机自动吞掉后面 2 个字节 (`10...`, `10...`) 组合在一起。
    * **不会读错**：因为 'H' 开头不是 `11110`，'中' 开头也不是 `11110`，所以绝对不会误认为是 4 字节字符。