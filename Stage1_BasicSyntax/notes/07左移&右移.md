# Go 左移（<<）/ 右移（>>）位运算完全解析

## 核心前提

位运算操作的是**二进制位（0/1）**，所有十进制数字会先转为二进制，执行移位后再转回十进制。以下示例均以 8 位整数（uint8/int8）展示（方便可视化，实际 Go 中 int 为 64 位）。

------

## 一、左移（<<）：整体左挪，右边补 0

### 1. 核心规则

`x << n`：将 `x` 的二进制位**全部向左移动 n 位**

- 左边超出类型位数的部分直接丢弃；
- 右边空出的位置统一补 `0`；
- 无溢出时，等价公式：`x << n = x × 2ⁿ`（新手优先记这个快速计算技巧）。

### 2. 直观示例（uint8 无符号数）

| 十进制 x | x 的二进制（8 位） | 移位操作 | 移位后二进制 | 结果（十进制） |  等价计算   |
| :------: | :----------------: | :------: | :----------: | :------------: | :---------: |
|    1     |     0000 0001      |  1 << 0  |  0000 0001   |       1        | 1 × 2⁰ = 1  |
|    1     |     0000 0001      |  1 << 1  |  0000 0010   |       2        | 1 × 2¹ = 2  |
|    3     |     0000 0011      |  3 << 2  |  0000 1100   |       12       | 3 × 2² = 12 |
|    8     |     0000 1000      |  8 << 3  |  0100 0000   |       64       | 8 × 2³ = 64 |

### 3. 注意：溢出问题（新手易踩坑）

左移超出类型位数时，左边位会被丢弃，此时不再满足 `×2ⁿ`：

go

运行

```
// uint8 最大值为 255（二进制 1111 1111）
var a uint8 = 128 // 二进制：1000 0000
fmt.Println(a << 1) // 左移1位：0000 0000 → 结果=0（而非 128×2=256）
```

------

## 二、右移（>>）：分无符号 / 有符号两种场景

### 1. 无符号数右移（uint 类型）：整体右挪，左边补 0

#### 规则

`x >> n`：将 `x` 的二进制位**全部向右移动 n 位**

- 右边超出的部分丢弃；
- 左边空出的位置补 `0`；
- 等价公式：`x >> n = x ÷ 2ⁿ`（整数除法，向下取整）。

#### 示例（uint8）

| 十进制 x | x 的二进制（8 位） | 移位操作 | 移位后二进制 | 结果（十进制） |       等价计算        |
| :------: | :----------------: | :------: | :----------: | :------------: | :-------------------: |
|    6     |     0000 0110      |  6 >> 1  |  0000 0011   |       3        |       6 ÷ 2 = 3       |
|    12    |     0000 1100      | 12 >> 2  |  0000 0011   |       3        |      12 ÷ 4 = 3       |
|    7     |     0000 0111      |  7 >> 1  |  0000 0011   |       3        | 7 ÷ 2 = 3（向下取整） |

### 2. 有符号数右移（int 类型）：整体右挪，左边补符号位

#### 规则

`x >> n`：右边丢弃，左边补**符号位**（正数补 0，负数补 1），保证数值符号不变。

#### 示例（int8 负数）

go

运行

```
var b int8 = -6 // 二进制（补码）：1111 1010
fmt.Println(b >> 1) // 右移1位：1111 1101 → 十进制=-3

var c int8 = -7 // 二进制：1111 1001
fmt.Println(c >> 1) // 右移1位：1111 1100 → 十进制=-4（-7÷2=-3.5，向下取整为-4）
```

------

## 三、新手必记核心对比表

|     操作类型      | 移动方向 |    补位规则（关键）    | 等价计算（无溢出） |
| :---------------: | :------: | :--------------------: | :----------------: |
|     左移 `<<`     |    左    |   右边补 0，左边丢弃   |       x × 2ⁿ       |
| 无符号数右移 `>>` |    右    |   左边补 0，右边丢弃   | x ÷ 2ⁿ（向下取整） |
| 有符号数右移 `>>` |    右    | 左边补符号位，右边丢弃 | x ÷ 2ⁿ（向下取整） |

------

## 四、可运行验证代码

go

运行

```
package main

import "fmt"

func main() {
    // 左移示例
    var x uint8 = 3
    fmt.Println("3 << 2 =", x << 2) // 输出 12

    // 无符号右移示例
    var y uint8 = 7
    fmt.Println("7 >> 1 =", y >> 1) // 输出 3

    // 有符号右移示例
    var z int8 = -7
    fmt.Println("-7 >> 1 =", z >> 1) // 输出 -4
}
```

------

### 总结

1. 左移核心：**左挪、右补 0**，无溢出时等价于 ×2 的 n 次方，溢出则左边位丢弃；
2. 右移核心：无符号数**右挪、左补 0**，有符号数**右挪、左补符号位**，均等价于 ÷2 的 n 次方（向下取整）；
3. 避坑点：左移不是 “二进制前面加 1”，而是所有位整体移动，溢出会导致结果不符合 ×2ⁿ 规律。