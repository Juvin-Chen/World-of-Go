# 📘 第 3 章：Go 语言核心容器与指针

本章节涵盖了 Go 语言处理数据的核心工具：数组、指针、结构体、切片、Range 迭代以及 Map 集合。

------

## 1. 数组 (Array)：定长的基石

数组是具有相同类型且长度固定的序列。在 Go 中，**长度是类型的一部分**。

- **声明与初始化**：
  - 标准声明：`var arr [5]int`
  - 字面量：`nums := [3]int{1, 2, 3}`
  - 推导长度：`balance := [...]float32{10.0, 2.0, 3.0}`
  - 指定索引：`special := [5]int{1: 20, 3: 40}`
- **核心特性**：
  - **值类型**：传参时会发生全量拷贝。在函数内修改数组不会影响原数组。
  - **固定性**：`[3]int` 和 `[5]int` 是完全不同的类型，不能互相赋值。
  - **二维数组**：`matrix := [2][3]int{{1,2,3}, {4,5,6}}`。

------

## 2. 指针 (Pointer)：内存的地址符

指针存储的是另一个变量的内存地址。Go 具有指针，但**不支持指针运算**（如 `p++`）。

- **基本操作**：
  - `&` 取地址符：获取变量的内存地址。
  - `*` 取值符：获取指针指向地址的具体内容（解引用）。
- **空指针**：未分配变量的指针值为 `nil`。
- **高级用法**：
  - **指针数组**：`var ptrArr [3]*int`（存一堆地址）。
  - **二级指针**：`var pptr **int`（指向指针的指针）。
- **与 C++ 差异**：Go 的指针主要用于结构体传递和修改原数据，极少使用多级指针。

------

## 3. 结构体 (Struct)：自定义复合类型

结构体用于将不同类型的数据组合成一个逻辑实体。

- **定义与实例化**：

  Go

  ```
  type Book struct {
      title, author string
      book_id int
  }
  b1 := Book{"Go", "Teacher", 101}
  b2 := Book{title: "Go", author: "Anon"} // 推荐方式，可忽略部分字段
  ```

- **访问**：使用点号 `.` 访问成员。

- **结构体指针**：Go 做了语法糖优化，`ptr.title` 等同于 `(*ptr).title`，使用起来非常自然。

------

## 4. 切片 (Slice)：动态的“数组窗口”

切片是对数组的抽象，长度可变，是 Go 实际开发中最常用的数据结构。

- **创建方式**：
  - `make` 创建：`s := make([]int, len, cap)`
  - 从数组截取：`s := arr[start:end]`（左闭右开）。
- **核心函数**：
  - `len()`：当前元素个数。
  - `cap()`：底层数组容量。
  - `append()`：向切片追加元素（可能触发扩容）。
  - `copy(dest, src)`：深拷贝切片内容。
- **注意**：切片是引用传递（底层是指针、长度和容量的结构体）。

------

## 5. Range 迭代器：优雅的遍历

`range` 关键字可以迭代切片、数组、Map 和字符串。

- **返回规则**：
  - **数组/切片**：返回 `index, value`。
  - **Map**：返回 `key, value`。
  - **字符串**：返回 `index, char(rune)`。
- **忽略技巧**：
  - 只取 Key：`for k := range myMap`
  - 只取 Value：`for _, v := range myMap`

------

## 6. Map (集合)：哈希键值对

Map 是无序的键值对集合，底层通过哈希表实现。

- **初始化**：
  - 必须使用 `make` 或字面量：`m := make(map[string]int)`。未初始化的 Map 值为 `nil`，直接赋值会崩溃。
- **CRUD 操作**：
  - **插入/修改**：`m["key"] = value`
  - **获取**：`v, ok := m["key"]`（`ok` 用于判断键是否存在）。
  - **删除**：`delete(m, "key")`。
- **特性**：
  - **无序性**：每次遍历 Map 的顺序可能都不同。
  - **引用类型**：函数间传递 Map 不会拷贝底层数据。

------

### 💡 章节总结：如何选择？

| **数据结构** | **长度是否固定** | **传参行为**  | **适用场景**                         |
| ------------ | ---------------- | ------------- | ------------------------------------ |
| **数组**     | 是               | 值拷贝 (重)   | 特定长度的底层算法、内存布局固定场景 |
| **切片**     | 否               | 引用传递 (轻) | 几乎所有序列化数据的首选             |
| **Map**      | 否               | 引用传递 (轻) | 需要快速索引、查表的键值对场景       |